module sv(clk, _rst, green, yellow, red);

output logic green, yellow, red;
input logic clk, _rst;
logic [25:0]Q;
logic n_clk, rst;
logic [5:0] Qu;

enum logic [1:0] {green = 2'b00, yellow, red} state, nextstate;

//регистр состояний
always_ff @(posedge clk, negedge _rst)
if ( !_rst )
state <= red;
else
state <= nextstate;

//регистр переключений
always_ff @(posedge schet, negedge rst)
	if (rst) Qu <= 0;
	else if (schet) Qu <= Qu + 1;
	else Qu <= Qu;

//комбинационная функция состояний
always_comb
	if (state == red) begin
		rst = 0;
		if (Qu==39) begin
		nextstate = green;
		rst = 1;
		end
		else if (clk) schet = 1;
		else schet = 0;
	end
	if (state == green) begin
		rst = 0;
		if (Qu==20) begin
		nextstate = yellow;
		rst = 1;
		end
		else if (clk) schet = 1;
		else schet = 0;
	end
	if (state == yellow) begin
		rst = 0;
		if (Qu==2) begin
		nextstate = red;
		rst = 1;
		end
		else if (clk) schet = 1;
		else schet = 0;
	end
	
//выходная комбинационная логика
assign green = (state == green) ? 1'b1 : 1'b0;
assign red = (state == red) ? 1'b1 : 1'b0;
assign yellow = (state == yellow) ? 1'b1 : 1'b0;

//делитель частоты
always_ff @(posedge clk, negedge _rst) 
	if (_rst || Q == 26'd49999999) Q <= 0;
	else if (clk) Q <= Q + 1;
	else Q <= Q;

assign n_clk = (Q == 26'd49999999) ? 1'b1 : 0'b0;

endmodule 